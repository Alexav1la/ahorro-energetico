
import { Repository } from "typeorm";
import { apartament as ApartamentEntity} from "../entities/apartament";
import { apartamentPort } from "../../domain/apartamentPort";
import { AppDataSourcet } from "../config/Data-base";
import { apartament as ApartamentDomain } from "../../domain/apartament";
import { expression } from "joi";


export class ApartamenAdapater implements apartamentPort {
    private apartamentRepository: Repository<ApartamentEntity>;

    constructor() {
        this.apartamentRepository = AppDataSourcet.getRepository(ApartamentEntity);
    }
    private toDomain( apartament: ApartamentEntity): ApartamentDomain{
        return {
            id : apartament.id_apartament,
            apartament_number: apartament.apartament_number,
            torre: apartament.torre,
            piso: apartament.piso,
            area_m2: apartament.area_m2,
            user_id: apartament.user_id,
            status: apartament.status
        };
    }

    private toEntity (apartament: Omit<ApartamentDomain, "id">): ApartamentEntity{
        const apartamentEntity = new ApartamentEntity();
        apartamentEntity.apartament_number = apartament.apartament_number;
        apartamentEntity.torre = apartament.torre;
        apartamentEntity.piso = apartament.piso;
        apartamentEntity.area_m2 = apartament.area_m2;
        apartamentEntity.user_id = apartament.user_id;
        apartamentEntity.status = apartament.status;
        return apartamentEntity;
    }

    async createApartament(apartament: Omit<ApartamentDomain, "id">): Promise<number> {
        try{
            const newApartament = this.toEntity(apartament);
            const savedApartament = await this.apartamentRepository.save(newApartament);
            return savedApartament.id_apartament;
        } catch (error){
            console.error ("Error al crear el apartamento", error);
            throw  new Error (" Error al crear apartamento");
        }
    }
    async getApartamentById(id: number): Promise<ApartamentDomain | null> {
        try{
            const apartament = await this.apartamentRepository.findOne({
                where:{id_apartament:id},
                relations: ["user"]
            });
            return apartament ? this.toDomain(apartament):null    
        } catch (error){
            console.error("Error al recuperar el apartamento por ID", error);
            throw new Error("Error al recuperar el apartamento por ID");
        }
    }

    async getApartamentByNumber(apartamentnumber: string): Promise<ApartamentDomain | null> {
        try{
            const apartament = await this.apartamentRepository.findOne({
                where:{apartament_number: apartamentnumber}
            });
            return apartament ? this.toDomain(apartament):null;
        } catch (error){
            console.error("Error al recuperar el apartamento por numero", error);
            throw new Error("Error al recuperar el apartamento por numero");
        }
    }

    async getApartamentByUserId(userId: number): Promise<ApartamentDomain[]> {
        try{
            const apartaments = await this.apartamentRepository.find({
                where:{ user_id: userId}
            });
            return apartaments.map(apartaments=> this.toDomain(apartaments));
        } catch (error){
            console.error("Error al recuperar el apartamento por usuario", error);
            throw new Error("Error al recuperar el apartamento por usuario");
        }
    }
    async getAllApartaments(): Promise<ApartamentDomain[]> {
        try{
            const apartaments = await this.apartamentRepository.find({
                relations: ["user"]
            });
            return apartaments.map(apartaments=> this.toDomain(apartaments));
        } catch (error){
            console.error("Error al recuperar apartamento", error);
            throw new Error("Error al recuperar apartamento");
        }
    }

    async updateApartament(id: number, apartament: Partial<ApartamentDomain>): Promise<boolean> {
        try{
            const existingapartament = await this.apartamentRepository.findOne({
                where:{id_apartament:id}
            });
            if (!existingapartament){
                return false;
            }
            if (apartament.apartament_number)existingapartament.apartament_number = apartament.apartament_number;
            if (apartament.torre)existingapartament.torre = apartament.torre;
            if (apartament.piso)existingapartament.piso = apartament.piso;
            if (apartament.area_m2)existingapartament.area_m2 = apartament.area_m2;
            if (apartament.user_id)existingapartament.user_id = apartament.user_id;
            if (apartament.status)existingapartament.status = apartament.status;
            await this.apartamentRepository.save(existingapartament);
            return true;
        }catch (error){
            console.error("Error al actualizar el apartamento", error);
            throw new Error("Error al actualizar el apartamento");
        }
    }
   async deleteApartament(id: number): Promise<boolean> {
    try {
        const existingApartament = await this.apartamentRepository.findOne({
            where: { id_apartament: id }
        });

        if (!existingApartament) {
            throw new Error("Apartment not found");
        }

        Object.assign(existingApartament, {
            status_apartament: 0
        });

        await this.apartamentRepository.save(existingApartament);
        return true;

    } catch (error) {
        console.error("Error deleting apartment:", error);
        throw new Error("Error deleting apartment");
    }
}


}